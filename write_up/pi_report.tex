\documentclass[a4]{report}
\def\atitle{Development of a Control System Using a Raspberry Pi}
\def\theauthor{Christopher Boyle}
\def\thewords{4189}


% Imports
\usepackage{graphicx}
\usepackage[a4paper]{geometry}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage{etoolbox}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage{subcaption}

% Unused packages
%\usepackage{placeins}
%\usepackage{fancyref}
%\usepackage[comma,authoryear]{natbib}
%\usepackage{lipsum}

% Settings
\geometry{top=2cm, bottom=2.5cm, left=3cm, right=2.5cm}
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{plain}}{}{}
\patchcmd{\section}{\thispagestyle{plain}}{\thispagestyle{plain}}{}{}
\patchcmd{\subsection}{\thispagestyle{plain}}{\thispagestyle{plain}}{}{}
\setcounter{secnumdepth}{0}
\renewcommand{\theequation}{\arabic{equation}}
\renewcommand\UrlFont{\rmfamily\itshape}
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{0pt}
\def\achapter{preamble}
%%%% TEMPLATES
\iffalse


%%%EQUATION

	\begin{equation}
		(THE EQUATION)
		\label{EQUATION REF}
	\end{equation}


%%%FIGURE

	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=SCALE]{IMAGE LOCATION}}
		\caption{CAPTION}
		\label{FIGURE REF}
	\end{figure} \newline  \noindent

%%%BULLET POINT LIST
	\begin{itemize}
	\item
	\end{itemize}

\fi
%%%%

% Header/footer preamble
\fancyhf{}
\fancypagestyle{plain}{
	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0.4pt}
%	\fancyhead[L]{\atitle}
	\fancyhead[L]{\achapter}
	\fancyhead[R]{\theauthor}
	\fancyfoot[L]{\today}
	\fancyfoot[R]{\thepage}
}
\pagestyle{plain}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%% TITLE PAGE
	\begin{titlepage}
		\makebox[\textwidth][c]{\includegraphics[scale=1]{images/titleheader.png}}
		\centering
		\vskip3cm
		{
			\bfseries\Large
			Department of Chemical \& Process Engineering\\
			\vskip1cm
			MEng in Chemical \& Process Engineering\\
			18530
			\vskip3cm
			\LARGE\atitle
		}
		\vskip3cm
		{\small Word Count: \thewords}
		\vskip1cm
		\begin{flushleft}
			This project is submitted in partial fulfilment of the regulations governing the award of \\
			Degree of MEng in Chemical Engineering at the University of Strathclyde
			\vskip2cm
			Your name: Christopher Boyle \hfill Date: \today
			\vskip1cm
			Organisation: University of Strathclyde, Department of Chemical \& Process Engineering\newline% \newline
			In-house Supervisor: Dr. Leo Lue \newline% \newline
			Academic Supervisor: Dr. Leo Lue
		\end{flushleft}
	\end{titlepage}

	%%%%%%%%%%%%%%%%%%% Main Content Settings
	\pagenumbering{roman}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN BODY PREAMBLE
	%%%%%%%%%% Summary Page
	\chapter*{Summary}
	\addcontentsline{toc}{chapter}{Summary}
	\def\achapter{Summary}
	%Brief, factual, generally following the same order of presentation as the report. Do not include figures, tables, or references.
	
	% Contents Page
	\def\achapter{Contents}
	\tableofcontents
	
	% Acknowledgements
	\chapter*{Acknowledgements}
	\addcontentsline{toc}{chapter}{Acknowledgements}
	\def\achapter{Acknowledgements}
	%It is a matter of honesty and courtesy that acknowledgement is made to those who helped you in your work.
	%Dr. Lue
	
	\newpage
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN BODY BEGIN PROPER
	\chapter*{Introduction}
	\addcontentsline{toc}{chapter}{Introduction}
	\def\achapter{Introduction}
	%The introduction sets the scene. It should include a brief description of the organisation, the type of work carried out, projects undertaken, background information to the work carried out and a brief outline of the report and of the learning objectives for the project.
	%History of what is being done, what is used to do it, how it is done.



	\section{Laboratory Automation and Process Control}
	Laboratory automation involves the design and implementation of robotic systems which are able to conduct laboratory experiments automatically, reducing the workload of human scientists and technicians \cite{backwhatisauto}. This includes the use of machine learning and AI to interpret results and create hypotheses \cite{backlitrevai, backbaconauto, backlabauto}. The motivation for this is eaasy to see, "Robot Scientists" can be used to conduct experiments with little to no human supervision and can take in a vast number of measurements. The "Adam" Robot Scientist developed by the team at Aberystwyth University can make over 200,000 measurements a day (moreover, it can make over 1,000,000 other observations and hypotheses per day)  \cite{backontorobsci}. \newline \newline \noindent
	%More history?
	Laboratory automation is similar in concept to process control, both using computers to manage the running of a process. %more information?
	Process control is an inherent area of process design. The process (whatever it may be) has parameters which must be controlled so that the process continues to work as designed. Process control has historically been achieved through the use of analogue equipment which vary a control signal depending on the measured parameter. Modern process control is achieved through the use of computers and digital electronics. The measured signals are converted into digital binary signals that can be read in by the controlling computer which applies an \textit{algorithm} to calculate the required control action to maintain the desired value of the variable. The algorithms used vary between controller applications. The most commonly used algorithm is the Proportional-Integral-Derivative Control Algorithm (PID control). This algorith consists of three sections which can be turned off or on depending on the situation. The proportional control element increases the control action directly in proportion to the size of the error (the difference between the set point and the measured value), this offers good, simple control, however it suffers from bias (MOAR). Integral control increases the control action depending on the integral of the error with respect to time (the longer the error goes on, the higher the control action). Derivative control increases control action with the derivative of the error with respect to time, so a quickly rising error is met with a large change in control action. \newline \newline \noindent
	Each control element has an associated gain parameter which affects how strongly that element is represented in the control action. These parameters must be set properly before controller can be used. This is done in a process called tuning. There are a variety of methods for tuning the controller, most commonly used is the Ziegler-Nichols method, involving tuning the controller such that the measured value oscillates in a sustained way. Then using the period of oscillation along with other measured parameters to decide on the optimum controller tuning. After tuning using a method such as Ziegler-Nichols it is often required to tweak the tuning manually to obtain the most effective controller for the situation. This is done mostly by trial and error. Trial and error tuning can also be used to fully tune the device, although this would take a long time to do by hand. \newline \newline \noindent
	Electronic process controllers make use of small computers called microcontrollers to perform the calculation. A microcontroller chip is a small re-programmable "computer" which reads input from, and outputs data to an electronic circuit \cite{backwhatismc}. Microcontrollers are programmed by connecting them to a "master" computer which can set the data on the microcontroller's storage. Data is stored as binary data (data is stored solely in the form of 0s and 1s). The program is written in a programming language, a special set of instructions which the environment can understand and convert into actions (like saving a value to memory). \newline \newline \noindent
	
%	\begin{figure}[h!]
%	\centering
%	\fbox{\includegraphics[scale=0.5]{images/mcudia.png}}	\caption{Microcontroller Block Diagram (taken from  \cite{mcudia})}
%	\label{mcudia}
%	\end{figure}


%	more info on lab automation


	\section{Raspberry Pi}
	\noindent
	Microcontrollers are commonly used in education to teach computer programming \cite{backmcedu1, backmcedu2}. However, it was noticed that people were not properly learning about how computers work in schools and universities and so a team of academics at the University of Cambridge created the Raspberry Pi Foundation, and developed the Raspberry Pi Model A as a platform to facilitate education \cite{pihistory}. The Raspberry Pi is a small (85mm x 56mm \cite{pi3mechdraw}) computer. By default, it runs a version of GNU/Linux called "Raspian". There are a number of alternative operating systems suitable for different applications (media center, embedded smart technology) \cite{piotheros}.  \newline
	\begin{figure}[!htb]
	\centering
	\fbox{\includegraphics[scale=0.5]{images/pi3modelb.png}}
	\caption{Raspberry Pi 3 Model B (taken from  \cite{pi3info})}
	\label{pidia}
	\footnotesize Clockwise from top left: GPIO pins, USB ports, Ethernet port, audio jack, Camera Serial Interface (CSI), HDMI port, micro-USB power port, and Display Serial Interface (DSI).
	\end{figure} \newline% \noindent
	The first Raspberry Pi (Model A) had a single core 700MHz processor and 256MB of RAM \cite{pi1info}, while the current Raspberry Pi 3 Model B has a quad core 1.2GHz and 1GB of RAM (also including built in WiFi and Bluetooth) \cite{pi3info}. The quad core processor enables better multithreaded operation for software running on the Raspberry Pi, meaning that big cumbersome programs can run much more efficiently than before. In addition, the increase in memory and CPU clock frequency means there is overall a massive performance boost. Operations like compiling a large program (for example OpenCV, the Open Source Computer Vision Library) which would take over 9 hours \cite{pipowercompold} on the Raspberry Pi 1, takes little over an hour and a half \cite{pipowercompnew} on the lastest model.\newline \newline  \noindent
	Despite being initially designed for educational purposes, the Raspberry Pi has found success in other areas such as with hobbyists \cite{pihobbynotedu} and in industry \cite{pimorethanedu}. What makes the Raspberry Pi attractive in process control are the GPIO (General Purpose Input/Output, see Figure \ref{pidia}) pins made available on the main board, similar to a microcontroller. These pins allow electronic circuits to interface with the Raspberry Pi, and thus software to interact with the real world in a way that is not easy to accomplish with a traditional computer. This marriage of microcontroller and desktop computer allows for incredibly easy development and testing in a single package. In addition to this, the Raspberry Pi retails (at the time of writing) for \pounds 30.00 \cite{picost} making it a very cost effective alternative to other control solutions (which can cost several hundred pounds \cite{otherpcucost}). Each of the GPIO pins is numbered so that they can be referenced, see Figure \ref{gpiopinout} for the layout.\newline
	\begin{figure}[!htb]
	\centering
	\fbox{\includegraphics[scale=0.2]{images/gpiopinout.png}}
	\caption{Raspberry Pi 3 Model B GPIO Pinout Diagram (taken from  \cite{pigpiopinout})}
	\label{gpiopinout}
	\end{figure} \newline  \noindent
	In addition to simple GPIO functionality, some of the Raspberry Pi's GPIO pins have special functionality, like the ability to use serial communication making inter-device communication much easier. To send the number 1750 to an integrated circuit, the Raspberry Pi would need at least 11 free GPIO pins. While this is not impossible, the number of GPIO pins taken up by the single device is extremely inconvenient. This can easily be sent via serial connection with just two wires. Pins 3 and 5 can also be used to communicate with integrated circuits with the \(I^2 C\) protocol (Inter-Integrated Circuit). This allows bytes of data to be sent over only two wires \cite{backwhatisi2c}. This is done by \textit{serial communication}. Serial communication is where each bit of data (starting with the most significant bit, the highest value bit) is sent one after the other down a wire (the "data" line) \cite{backwhatisserpar} while another wire is used to synchronise the communication beteween devices (the "clock" line). Pins 19, 21, 23, 24, and 26 are used for another serial communications protocol, the Serial Peripherial Interface (SPI) protocol \cite{backwhatisspi}. SPI is similar to \(I^2 C\), although it differs in a few key ways.  \(I^2 C\) manages sub devices on the network using an address system which enables anything up to 128 devices connected together in one go, however SPI uses a simple select system where a signal is sent from a GPIO to the SPI device to tell it to expect instruction. This makes the SPI device far easier to work with, but less useful as the number of daisy-chained devices is limited by the number of free GPIO pins. \newline \newline  \noindent
	The high level languages used to create programs on desktop computers can be similarly used to write programs on the Raspberry Pi (it is running a desktop operating system). There are a number of libraries (collections of software) available for facilitating the communication between the software and the GPIO pins. Built in to the Raspberry Pi are some basic libraries offering simple functionality, but there are third-party libraries available for anyone to download and use\cite{pilibswiringpi, pilibspigpio}. The programming language "Python" is popular among software developers. Python is a high level, object oriented, interpreted language, making it well suited to quickly developing clean, and easy to use object-oriented software. Due to its popularity, Python has a vast number of packages available to perform any number of functions. \newline \newline \noindent


	\section{Colloidal Suspensions and Jamming}
	"Normal" fluids (like water) exhibit Newtonian behaviour, this means that the rate of shear (how fast they deform) is directly proportional to the shear stress imposed upon them, with the constant of proportionality being the viscosity of the fluid\cite[p.~252]{schadict}. Multiphase suspensions can exhibit non-Newtonian viscous behaviour, where this direct relationship is not found \cite[p.~255-256]{schadict}. Some exhibit a shear-thickening behaviour: as the shear stress is increased, the shear rate decreases faster than in newtonian behaviour and others exhibit shear thinning \cite{backtypesofnonnewt}. Figures \ref{figshearthin} \& \ref{figshearthick} give examples of how shear rate varies with shear stress for non-newtonian fluids. Shear thickening behaviour can be split into further categories: continuous shear thickening, and discontinuous shear thickening. Continuous shear thickening (shown in Figure \ref{figshearthick})  is an increase in the apparent viscosity. Discontinuous shear thickening is a sudden and extreme increase in the apparent viscosity of the fluid and is closely related to jamming, which is \textit{"the conversion of a liquid system into a solid by imposed stress"} \cite{backhawjam}. Jamming is found in many different systems: in solids entering a hopper \cite{back2djam}, in pedestrians walking down a corridor \cite{backpedjam}, and in traffic \cite{backcarjam}. This can cause problems in processes: halting flow, damaging mixing equipment \cite{backshearjambertrand}. \newline \newline \noindent
	%Particles in a suspension can be of different shapes. The shape most often considered is the Hard Sphere (HS). HS particles are spherical and do not interact (WHAT) \newline
	Volume fraction of the suspension mixture is an important property when looking at jamming. A suspension's volume fraction (\( \Phi \)) is the ratio of the volume of suspended particles to the volume of fluid in the suspension. For spherical particles, there is a maximum fraction. The closest packing that can occur (face-centred cubic) results in a particle volume fraction of \( \Phi = 0.74 \). However, at this packing the suspension is no longer a suspension and the particles are all in constant contact. The highest volume fraction of a suspension that still allows fluid to pass between the particles (particles are lubricated) is \( \Phi = 0.64 \) \cite{backguypoonjam}. As volume fraction increases, the likelihood of a suspension to undergo jamming increases (CITE).
	\begin{figure}[!htb]
		\centering
		\fbox{
		\begin{subfigure}[t]{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{figures/fig_shear_behav_thin.png}
			\caption{Shear Thinning}
			\label{figshearthin}
		\end{subfigure}
		\begin{subfigure}[t]{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{figures/fig_shear_behav_thick.png}
			\caption{Shear Thickening}
			\label{figshearthick}
		\end{subfigure}
		%\fbox{\includegraphics[scale=0.25]{figures/fig_shear_behav.png}}
		}
		\label{figshearthinthick}
		\caption{Graphs Showing Non-Newtonian Behaviour (adapted from \cite{figshearthin, figshearthick})}
	\end{figure} \newline  \noindent
	%flow, shear, jam frequency %TODO
	An interesting phenomenon that occurs in shearing suspensions is the formation and dissipation of "cracks" on the surface of the suspension. This can be directly seen in Figure \ref{cforscracks}. The cracks have been associated with a localized change in volume faction of the suspended particles \cite{backhawjam}. Another interesting optical property of jammed suspensions: the surface of a shear suspension has been found to alter texture, evidence of "Dilation" \cite{backbrownjaegrev}: caused by the particles in shear attempting to move around each other but having to take an inefficient route therefore decreasing the volume fraction of the suspension. This draws more fluid into the bulk and then the surface appears rough in texture, as opposed to glossy. 
\newline \newline \noindent
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=0.4]{images/cfors_cracks.png}}
		\caption{Suspension Surface Cracks (taken from \cite[p.~118]{thescforsyth})}
		\label{cforscracks}
	\end{figure} \newline  \noindent
	
	\section{This Project}
	This project aims to design, build, and test a control system for an experimental set up revolving around gathering more information about the occurrence of the "jamming" phenomenon in a colloidal suspension undergoing shear. Specifically, the experiment aims to gather more information about the statistical probability of the occurrence of a jam and how the shear stress affects this. 
	The experimental process consists of two concentric cylinders, the inner of which is attached to a DC motor and can be rotated. The gap between the two cylinders will be filled with a colloidal suspension. As the inner cylinder is rotated, the suspension will be subject to a constant shear force/constant shear rate. The torque output from the motor , as well as its rotational speed, will be recorded to give an indication of the rheology of the suspension. A needle strain gauge (The PiezoElectric Needle Device) will be mounted above the surface of the shearing suspension in order to measure the stress directly experienced by the fluid (rather than the applied stress which is being controlled). \newline \newline \noindent
	To find out how the formation of the cracks on the fluid's surface during shear correlate with the occurrence of discontinuous shear thickening, a camera will be aimed at the surface of the shearing fluid throughout the course of the experiment. The camera will be optically magnified using lenses placed in front of the aperture and will record images, which can later be processed using image recognition software to detect the formation of the cracks. \newline \newline \noindent
%	The motor's rotational speed will be set at different values and will be controlled to ensure the speed is maintained. The PEND can be used to detect the torque imposed upon the fluid (and thus the shear stress) by recording the potential difference across the crystal as the needle is deflected by the moving fluid and thus distorts the piezoelectric crystal.  \newline \newline \noindent
	The experimental set-up will be controlled by a Raspberry Pi 3 Model B. The Raspberry Pi's low cost, low power consumption, and GPIO availability make it a suitable choice for the controller to this process. Software will be developed for the Raspberry Pi to read in the motor's speed and the PEND's voltage reading, record it accurately and to control the rotational speed of the motor. In addition, the Raspberry Pi can be used to automate the experimental process by automatically altering experimental parameters in-between runs while logging all the relevant data during runs. The Pi can also be set up with a web interface, allowing monitoring of the experiment from remote locations, further reducing the manual workload on lab technicians.



	%\chapter*{Description of the Organisation}
	%\addcontentsline{toc}{chapter}{Description of the Organisation}
	%In this section, you should show a good understanding of the organisation. Details may include the type of organisation, management structure, products, and markets catered for. Mention your position in the organisation.
	



	\chapter*{Description of the Work}
	\addcontentsline{toc}{chapter}{Description of the Work}
	\def\achapter{Description of the Work}
	%Elaborate on issues mentioned in introduction. Use a logical development, not necessarily in chronological order. Explain the significance, purpose and nature of your work. Describe methods used and outcomes. Try to ensure a balanced treatment of issues, in accordance with their relative importance, and excluding irrelevant material. Present results and discuss around them. Explain the significance of these results and their impact on the organisation. Comment on technical difficulties you may have experienced. In a long report, subdivide with appropriate sub-headings, or divide this section into different sections. Equations should be numbered sequentially.



	\section{Experimental Setup}
	The experiment is based around a Couette (CITE) consisting of two concentric cylinders with a fluid in between. The inner cylinder can be rotated by a DC motor (SERNO) while the outer cylinder is fixed. The motor is controlled by a raspberry pi, which sets its speed (voltage) and reads in the torque load on the motor. This is used to calculate the viscosity of the fluid. A needle attached to a piezo-electric (PEND) is used to detect shear stress at a point within the fluid. When the liquid undergoes jamming, then the needle will move and generate a voltage proportional to the amount it moves. Figure \ref{expdia} gives a diagram of the set-up.\newline
	\begin{figure}[!htb]
	\centering
	\fbox{\includegraphics[scale=0.4]{images/blank.png}}
	\caption{Diagram of the Experimental Apparatus (from )}
	\label{expdia}
	\end{figure} \newline  \noindent



	\section{Electronic Circuits}
	%in depth description of relevant electronic circuits
	The electronic circuits attached to the Raspberry Pi can be split into three distinct sections. The motor speed detection circuit converts the rotational speed of the motor to a digital signal, the motor speed control converts a digital signal into rotation of the motor, and the PEND signal processing circuit converts the analogue signal from the PEND into a digital signal. All of the circuits are designed in order to facilitate the communication between the real world and the software running on the Raspberry Pi. 



	\subsection{\textit{Motor Speed Detection}}
	%Hall Effect
	The rotational speed of the motor is detected by attaching a magnet to the rotating cylinder and detecting how many times the magnet passes a Hall effect sensor (US5881) in a given time span. Four magnets will be attached to the motor, equally spaced. Thus, every time a magnet triggers the sensor it corresponds to a quarter turn. The Hall Effect Sensor is powered by the Raspberry Pi's 5v line and connected to ground. The output pin will be in a high state (0.6v) until the sensor detects the south pole of a magnet, at which point the output will go low (0v). To communicate with the Raspberry Pi, this signal must be converted into 3.3v logic (either a 3.3v high signal or 0v low signal). To achieve this, GPIO pin 23 on the Raspberry Pi was pulled high (set to a high logic signal) and connected through a transistor to ground. Normally, the high input to the transistor allows the flow of current from the GPIO pin to ground, meaning it has a low value. When the hall effect sensor detects a magnet the high signal to the transistor will block the flow of current between the GPIO pin and ground - the GPIO pin will go high. Figure \ref{circhall} shows the schematic of this circuit. \newline
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=0.4]{images/circspeeddet.png}}
		\caption{Circuit Schematic Diagram: Motor Speed Detection}
		\label{circhall}
	\end{figure} \newline  \noindent
	This circuit does not measure the instantaneous rotational speed of the motor. Instead it measures the average speed. By using more magnets, and a smaller time-frame, the speed measured becomes closer to an instantaneous speed. The advantage of using this circuit is that it is simple to set up and use, other speed detection circuits require the use of lasers and photodiodes/phototransistors, or dc dynamos and analogue to digital converters. However, the main downside lies in having to attach magnets at regular intervals to the rotating cylinder, which will have to be done accurately. Another downside is the range of the hall effect sensor. The sensor must be within 10mm of the magnet for it to be able recognise it. \newline \newline \noindent


	\subsection{\textit{Motor Speed Control}}
	The speed of the motor is sent from the Raspberry Pi as a digital serial signal (using the SPI protocol) to a digital potentiometer (MCP4131), a device which can electronically adjust the resistance between its pins. Figure \ref{circdigpotclose} highlights the resistances in the potentiometer: \(R_{AW}\) is the resistance between the A terminal pin on the potentiometer and the wiper pin and \(R_{WB}\) is the resistance between the wiper pin and the B terminal pin. The data sent to the potentiometer determines the values of \(R_{AW}\) and \(R_{WB}\), which will total a constant value (\(R_{pot} = 10,000\Omega \), in this case). The digital potentiometer is used in a voltage divider configuration, which allows the voltage in a parallel circuit to be controlled. When the resistance is changed to a new value, the voltage across the motor will change according to Equation \ref{eqnvoldiv}. The digital potentiometer can only handle voltages up to 5v across its terminals, an amplifier is used to boost the voltage range from 1.2v to 5v up to 2.6v to 10.5v. A transistor (BD243C) is used to boost the current output from the amplifier, which can only supply around 20mA. The Transistor boosts this up to 2A, assuming a conservative gain of hFE = 100.\newline
	
	%%%%%%%%%% REDO?
	\begin{equation}
		V_{out} = V_{in}\times \frac{R_2 + R_{WB}}{R_2 + R_{pot}}
		\label{eqnvoldiv}
	\end{equation}\newline
	\begin{equation}
		V_{min} = V_{in}\times \frac{R_2}{R_2 + R_{pot}}
		\label{eqnminvol}
	\end{equation}\newline
	\begin{equation}
		V_{max} = V_{in}\times \frac{R_2 + R_{pot}}{R_2 + R_{pot}} = V_{in}
		\label{eqnmaxvol}
	\end{equation}\newline \noindent
	The Raspberry Pi sets the motor speed by setting the resistance in the digital potentiometer. The resistance is sent as a number between 0 and 127. Within the potentiometer is a network of resistors, and this number will determine the path the circuit takes through the circuit, the higher the number, the higher the resistance between the A terminal and the wiper, \(R_{AW}\). When this increases, the voltage across the bottom resistor will decrease and the voltage across the motor will mirror this. Similarly, when \(R_{AW}\) decreases, the voltage in the bottom half of the divider will increase and so will the voltage across the motor. The resistors included in addition to the digital potentiometer set the minimum and maximum values for the voltage across the motor, the minimum voltage is where the wiper resistance is essentially zero, so Equation \ref{eqnvoldiv} becomes Equation \ref{eqnminvol}. For maximum voltage, the wiper is set as high as possible (\(R_{WB} = R_{pot}\)) and Equation \ref{eqnvoldiv} becomes Equation \ref{eqnmaxvol}. \newline
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=0.2]{images/circdigpotclose.png}}
		\caption{Circuit Schematic Diagram: Digital Potentiometer Detail}
		\label{circdigpotclose}
	\end{figure} \newline  \noindent
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[width=\textwidth]{images/circspeedcontr.png}}
		\caption{Circuit Schematic Diagram: Motor Speed Control ADD RESISTOR NAMES}
		\label{circspeedcontr}
	\end{figure} \newline  \noindent


	\subsection{\textit{PEND Signal Processing}}



	\section{Software}
	To manage the hardware connected to the device, software was written in Python, using software packages from its extensive (community driven) online repositories. The object-oriented nature of the language was fully utilised in order to create class-based code that was easy to read so that another person wanting to use the software would be able to understand how it works. In addition, the classes make it easy to add additional functionality to the experiment (adding other sensors or motors to increase the scope of the experiment). The software was composed of five main classes: exp\_run.py, control.py, motor.py, dig\_pot.py, and adc.py. \newline \newline \noindent
	A master script controls all of the classes and controls the overall flow. It looks for run information and checks whether there are runs to be done. Data defining the parameters of the experimental runs is contained in a comma separated value (CSV) file. This information is read in by the \(exp\_run\) class, which uses this to run the motor at the correct speed using the \(motor\), \(dig\_pot\), and \(control\) classes. The PEND sensor input is read in using the \(adc\) class. See Figure \ref{codemap} for a diagram of communication between the classes. \newline 
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=0.3]{images/codemap.png}}
		\caption{Code Map Diagram}
		\label{codemap}
	\end{figure}
	
	\subsection{exp\_run.py}
	The main control loop creates a new instance of the exp\_run class to manage the running of an experimental run. The run begins by reading in the run parameters from file dictating the length of the run, and the motor rotational speed. Also, new instances of the control, motor, and adc classes are created. The main loop managing the run begins by getting the current motor speed, using the control class to obtain a new motor voltage value, and setting this new value. The adc class is used to read in the PEND value, which is recorded along with the motor speed and the current time.
	\subsection{control.py}
	The control class is an implementation of a discrete PID control algorithm (Equation \ref{eqnvelocityalgo} \cite[p.~14]{PIDcontroldiscr}). This algorithm uses three parameters (\( K_P, K_I, and K_D\)), and the error between the current valueand the set point (\(e(n) = SP - y(n)\)) to obtain a value which should be output in order to maintain the output at the set point, defending against disturbances in the process.\newline
	\begin{equation}
		y(n) = y(n-1) + K_P (e(n) - e(n-1)) + K_I  e(n) + K_D (e(n) -2 e(n-1) + e(n-2))
		\label{eqnvelocityalgo}
	\end{equation}\newline \noindent
	Before it can be used, the PID algorithm parameters need to be tuned. This is done automatically by the controller. By performing a step test on the motor system, a model of the process can be formed. Using this model, the autotuning method analyses the different possibilities for the tuning parameters, checking how the controller with each tuning option handles a step change to the set point. Ideally, a tuned response should quickly rise to the new set point and not oscillate too much. (MORE WHY HOW)
	\subsection{motor.py}
	The motor class is used to manage the DC motor. It uses the dig\_pot class to control the speed and sets up a GPIO pin to read in information from the Hall Effect speed detection circuit. The motor class, when instantiated in the exp\_run script, will create a thread which will update the motor's speed value to the current value (every XX seconds). The program counts the number of times a magnet has passed the hall effect sensor (thus the number of rotations, or partial rotations, in a known time-frame). When the motor's speed is calculated, this count is reset to 0.
	\subsection{dig\_pot.py}
	This class is used to communicate with the digital potentiometer, setting the motor's supply voltage and thus its rotational speed. The digital potentiometer is communicated with using the SPI protocol. The resistance is set by sending it two bytes: the first byte is a command sequence, and the second is the value (see Figure \ref{mcp4131commfig}). Since the potentiometer has only a 7bit network of resistors (128 different configurations), the data only takes up the last 7 bits of the 16 bit sequence, the rest are ignored. The memory address is question is the first wiper register (there is only one, but the same syntax is used for ICs with more than one resistor network). Wiper register 0 is at register address 0. The command used here is the "write" command (binary: 00). The two data bits included in the first byte are unnecessary, so they are left zero also. The second byte is simply the desired value (between 0 and 127). \newline \newline \noindent
	This class makes use of the "spidev" python package, which supports the ability to communicate over SPI from a python script.
	\begin{figure}[!htb]
		\centering
		\fbox{\includegraphics[scale=0.3]{images/mcp4131commdat.png}}
		\caption{MCP4131 Command Syntax \cite[p.~47]{mcp4131datasheet}}
		\label{mcp4131commfig}
	\end{figure} \newline  \noindent
	
	\subsection{adc.py}
	Similar to the dig\_pot class, this class is used to communicate via a serial protocol with a device. The \(I^2C\) protocol is used here to communicate with an 18bit analogue to digital converter (ADC). This device allows the Raspberry Pi to read in a voltage value from a circuit by converting it into a digital signal. This signal has a resolution of up to 18 bits - a range of 0-262144 (WHAT ABOUT NEGATIVES?), therefore with a voltage range of -0.3v to 5.3v \cite{mcp3424datasheet}, each unit step represents a measured voltage of \(2.136\times10^{-5}V\). The class reads in the digital serial signal and converts it from the binary number into a voltage reading which can be used or recorded as necessary.



	\section{Procedure}
	%Experimental Procedures
	\subsection{Motor Calibration}
	There are several parameters that need to be calculated before the motor can be used in the rheometer. The torque and efficiency characteristic curves of the motor need to be calculated (OR FOUND??). To find this, the digital potentiometer was set to 0 and initial readings of the speed and voltage were taken. Then the value was incremented, the motor speed and voltage were recorded. This was done for every possible value for the digital potentiometer. Using the recorded information, a relationship was found between efficiency and speed. This allows the torque to be calculated using only the electrical power input to the motor, and the rotational speed of the motor (see Equation \ref{eqntorque}).
	\begin{equation}
	\tau = \frac{I \times V \times \eta}{\omega}
	\label{eqntorque}
	\end{equation}
	\subsection{Motor Torque Calibration (NECESSARY??)}
	The torque output from the motor with respect to the voltage applied to the motor must be known to be able to calculate the rheology of the liquid in the couette cell. There are two torques output from the motor: the load torque, and the shaft torque. The former is the torque imposed upon the load, and the latter is the torque imposed upon the motor's shaft. \newline \newline \noindent 
	There are limits upon the motor's output, at high enough torque, the rotational speed will reach zero. This torque value is the \textit{stall torque (\(\tau_s\))} and represents the maximum value of torque able to be output by the motor. The second limit is where the motor has no load imposed upon it. The torque here is the no-load torque (equal to the shaft torque). The rotational speed here is the greatest possible value (for a particular voltage) and can be used to calculate the no-load torque and thus the shaft torque. \newline \newline \noindent
	By recording the voltage and current through the motor, the power input to the motor can be calculated. Using the electrical power and the efficiency, the mechanical power output and the torque output can also be calculated. The speed at different loadings was recorded, giving the torque in terms of the voltage/current (power). (REWORD?)




	\chapter*{Conclusions}
	\addcontentsline{toc}{chapter}{Conclusions}
	\def\achapter{Conclusions}
	%Summarise findings and inferences mentioned in the core of the report. Try to be as brief as possible, with concise statements. Include recommendations, where appropriate. 
	



	\chapter*{Review}
	\addcontentsline{toc}{chapter}{Review}
	\def\achapter{Review}
	%Relate this section to the learning objectives in the introduction. Report what you have learnt about the organisation and about yourself. Mention your achievements, what you have learnt, skills you have acquired or improved. This might be technical or "soft" skills. Try to relate this to what you have learned in your coursework at University and what skills you will take forward to your first full time professional post.
	



	\chapter*{Nomenclature}
	\addcontentsline{toc}{chapter}{Nomenclature}
	\def\achapter{Nomenclature}
	%List all the symbols in alphabetical order, with Greek symbols at the end.
	\begin{center}
		\begin{tabular}{|c|l|}
			\hline
			\rule{1cm}{0pt}\textbf{Symbol}\rule{1cm}{0pt} & \rule{4cm}{0pt}\textbf{Description}\rule{4cm}{0pt} \\
			\hline
			\( R_{1} \) & Voltage divider resistor 1 resistance, ohms \\
			\hline
			\( R_{2} \) & Voltage divider resistor 2 resistance, ohms \\
			\hline
			\( R_{AW} \) & Potentiometer resistance between the wiper and the "A" terminal, ohms \\
			\hline
			\( R_{pot} \) & Potentiometer resistance, ohms \\
			\hline
			\( R_{WB} \) & Potentiometer resistance between the wiper and the "B" terminal, ohms \\
			\hline
			\( V_{out} \) & Voltage output from the potentiometer voltage divider, volts\\
			\hline
			\( V_{in} \) & Voltage input to the potentiometer voltage divider, volts\\
			\hline
			& \\
			\hline
			& \\
			\hline
			& \\
			\hline
			& \\
			\hline
			& \\
			\hline
			\( \mu \) & Viscosity, in Pa.s\\
			\hline
			\( \sigma \) & Shear Stress, in Pa\\
			\hline
		\end{tabular}
	\end{center}
	
	%Main Bibliography
	\newpage
	\addcontentsline{toc}{chapter}{Bibliography}
	\def\achapter{Bibliography}
	\bibliography{biblio}
	\bibliographystyle{unsrt}
	%\bibliographystyle{apalike}

%Appendix


\appendix


\chapter*{Appendices}
\addcontentsline{toc}{chapter}{Appendices}
\def\achapter{Appendices}
\pagenumbering{alph}
\setcounter{page}{1}
\setcounter{section}{1}
\section{Appendix 1 -  Programming Languages}
Programming languages come in many forms. High level languages (like C, Java, C\#, Python) are abstracted from the binary in which it will be eventually stored. High level languages consist of a natural-like language which is converted by a "compiler" or "interpreter" into machine code, understandable by the processor \cite{proglanghighlow}.\newline \newline  \noindent
\noindent
An example of a high level language (Python):
\begin{verbatim}
                    from time import time()

                    alarm_time = 2147483647

                    while (time() < alarm_time):
                              pass

                    print("Alert!")
\end{verbatim}
An example of a machine code (in hexadecimal)\cite{proglangmachex}:
\begin{verbatim}
                    0x 60 00 00 80
                    0x A4 00 00 00
                    0x 60 01 00 84
                    0x A4 01 01 00
                    0x 60 02 00 00
                    0x 60 03 00 04
                    0x 60 04 00 00
                    0x 60 05 00 01
                    0x 08 00 00 02
                    0x 20 00 00 03
                    0x 20 04 04 05
                    0x 11 20 04 01
\end{verbatim}
	From the above it can be seen that high level languages, while not strictly English, are far easier to read than machine code. Machine code will take multiple instructions to achieve the same thing that could be done in a single line in a high level language, thus a high level instruction needs to be converted into multiple machine level instructions for the processor to understand it. There are different ways of doing this, leading to diversity in the types of high level languages. (MISSING LINK). Object Oriented Programming Languages (OOPLs) deal with data in terms of "objects"\cite{proglangwhatisoopl}. An object is, like the name suggest, something. This something has properties, and can have things done to it. In the above Python example, "alarm\_time" is a number object, and it is being assigned a value. A "method" is a way of doing something in the program. In the above, the "time()" method is used to get the current time (in number of seconds since 1 January 1970). The advantage of OOPLs lies in the ability to collect objects and methods together in a class. The "time" class above contains a lot of methods which can be used by the programmer, in the example the "time.time()" method is called from the class. The programmer can therefore define a set of methods for dealing with some data in a certain way in a class, and then create multiple instances of this class with different starting data to make use of different starting data. For example, a "sphere" class could be written, with methods which provide the sphere's surface area and volume, given the sphere's diameter. Then a program could be written to create three sphere class instances, each with different diameters and then the areas and volumes could be calculate simply when needed. This creates tidy programs, which are easier to understand and reduces the amount of redundant code that needs to be written.\newline \newline  \noindent
	Another, less common, type of programming language is the procedural language. This language is simply one instruction following another\cite{proglangwhatisoopl}. The procedural program starts at the start and continues down the list of instructions until it finishes. This language requires writing out the same code multiple times to achieve the same effect as an OOPL, which is a reason for its reduced popularity.\newline \newline  \noindent
	As previously mentioned, code written in a programming language is usually compiled before it is run. However, some languages do not need to be compiled before being run. These languages are called "interpreted" languages and they are "compiled" line by line when you run them \cite{proglanginterp}. Since interpreted languages do not need to be compiled (and so software developers do not have to wait for the compilation step to complete before testing) they are preferred for developing software. However, they tend to run slower than compiled programs for the same reason.\newline \newline  \noindent
	To conclude this section,  programming languages are varied and have different advantages and disadvantages. The correct programming language must be chosen for the correct situation.\newline \newline  \noindent
%Other appendices, alternative circuits etc
%Appendix Bibliography

\end{document}